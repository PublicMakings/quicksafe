#!/usr/bin/env python

# quicksafe - The easiest way to securely encrypt notes
#
# Copyright (c) 2014 Philipp Emanuel Weidmann <pew@worldwidemann.com>
#
# Nemo vir est qui mundum non reddat meliorem.
#
# Released under the terms of the MIT License
# (http://opensource.org/licenses/MIT)

from Tkinter import *
from ScrolledText import ScrolledText
from tkSimpleDialog import askstring
from tkMessageBox import showwarning
from Crypto.Protocol.KDF import PBKDF2
from Crypto.Cipher import AES
from Crypto import Random
import os


# Cryptography methods adapted from http://stackoverflow.com/a/12525165
bs = AES.block_size

def pad(data):
    return data + (bs - len(data) % bs) * chr(bs - len(data) % bs)

def unpad(data):
    return data[:-ord(data[len(data)-1:])]

def get_cipher(password, iv):
    # Key derivation; adjust number of iterations as needed.
    # Note how the initialization vector doubles as a salt
    key = PBKDF2(password, iv, 32, 10000)
    return AES.new(key, AES.MODE_CBC, iv)

def encrypt(data, password):
    # Compress before encrypting
    data = pad(data.encode('zlib'))
    iv = Random.new().read(bs)
    return (iv + get_cipher(password, iv).encrypt(data)).encode('base64')

def decrypt(data, password):
    data = data.decode('base64')
    iv = data[:bs]
    return unpad(get_cipher(password, iv).decrypt(data[bs:])).decode('zlib')


def ask_password(caption):
    return askstring(caption, '', show='*')

def open_handler():
    global password
    password = ask_password('Enter Password')
    if not password: sys.exit()
    try:
        scrolled_text.insert(END, decrypt(ciphertext, password))
    except:
        # (Most likely) wrong password => try again
        open_handler()

def close_handler():
    global password
    # Omit additional newline returned by ScrolledText widget
    text = scrolled_text.get('1.0', 'end-1c')
    if not password and not text: sys.exit()
    if not password:
        password1 = ask_password('Set Password')
        if not password1: return
        password2 = ask_password('Confirm Password')
        if not password2: return
        if password1 != password2:
            showwarning('Warning', 'Passwords do not match')
            # Try again
            close_handler()
            return
        password = password1
    with open(__file__, 'w') as file:
        file.write(match.group(1) + '\n' +
                   encrypt(text, password) + match.group(3))
    root.destroy()


# Set up GUI
root = Tk(className=' '+os.path.basename(__file__))
root.protocol('WM_DELETE_WINDOW', close_handler)
root.withdraw()
scrolled_text = ScrolledText(root, wrap=WORD, highlightthickness=0)
scrolled_text.pack(fill=BOTH, expand=True)

password = None

# Parse script file
pattern = re.compile(r"(.*^'''\[DATA\])(.*)(\[/DATA\]'''.*)",
                     re.MULTILINE | re.DOTALL)
with open(__file__, 'r') as file:
    match = pattern.match(file.read())

ciphertext = match.group(2).strip()
if ciphertext: open_handler()

root.deiconify()
root.mainloop()


# Encrypted text follows
#
# !!!CAUTION!!!: Do not modify anything after this comment or
#                your text might be permanently lost!

'''[DATA]
[/DATA]'''
